import heapq, time, itertools


goal_state = (1, 2, 3, 4, 5, 6, 7, 8, 0)
goal_pos = {n: (i // 3, i % 3) for i, n in enumerate(goal_state)}

def is_solvable(state):
    s = [x for x in state if x != 0]
    inv = sum(1 for i in range(len(s)) for j in range(i+1, len(s)) if s[i] > s[j])
    return inv % 2 == 0

def get_neighbors(state):
    i = state.index(0)
    x, y = divmod(i, 3)
    moves = []
    for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
        nx, ny = x+dx, y+dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            j = nx*3+ny
            new_state = list(state)
            new_state[i], new_state[j] = new_state[j], new_state[i]
            moves.append(tuple(new_state))
    return moves


def h_misplaced(state):
    return sum(1 for i, v in enumerate(state) if v != 0 and v != goal_state[i])

def h_manhattan(state):
    return sum(abs(goal_pos[v][0] - i//3) + abs(goal_pos[v][1] - i%3)
               for i, v in enumerate(state) if v != 0)

def h_linear_conflict(state):
    manhattan = h_manhattan(state)
    conflict = 0
  
    for row in range(3):
        tiles = [state[row*3 + c] for c in range(3)]
        for i in range(3):
            for j in range(i+1, 3):
                if tiles[i] and tiles[j]:
                    gi, gj = goal_pos[tiles[i]], goal_pos[tiles[j]]
                    if gi[0] == gj[0] == row and gi[1] > gj[1]:
                        conflict += 1
  
    for col in range(3):
        tiles = [state[col + 3*r] for r in range(3)]
        for i in range(3):
            for j in range(i+1, 3):
                if tiles[i] and tiles[j]:
                    gi, gj = goal_pos[tiles[i]], goal_pos[tiles[j]]
                    if gi[1] == gj[1] == col and gi[0] > gj[0]:
                        conflict += 1
    return manhattan + 2 * conflict


def astar(start, heuristic):
    if not is_solvable(start):
        return None, 0, 0
    start_time = time.time()
    frontier = []
    heapq.heappush(frontier, (heuristic(start), 0, start))
    came_from = {start: None}
    g = {start: 0}
    expanded = 0
    while frontier:
        _, cost, state = heapq.heappop(frontier)
        expanded += 1
        if state == goal_state:
            path = []
            while state:
                path.append(state)
                state = came_from[state]
            return path[::-1], expanded, time.time() - start_time
        for nxt in get_neighbors(state):
            new_cost = cost + 1
            if nxt not in g or new_cost < g[nxt]:
                g[nxt] = new_cost
                f = new_cost + heuristic(nxt)
                heapq.heappush(frontier, (f, new_cost, nxt))
                came_from[nxt] = state
    return None, expanded, time.time() - start_time


puzzles = {
    "Goal": (1,2,3,4,5,6,7,8,0),
    "Easy": (1,2,3,4,5,6,0,7,8),
    "Medium": (1,3,6,5,2,0,4,7,8),
    "Hard": (1,6,7,5,0,3,4,8,2),
    "VeryHard": (8,6,7,2,5,4,3,0,1),
    "Unsolvable": (1,2,3,4,5,6,8,7,0)
}

heuristics = {
    "Misplaced": h_misplaced,
    "Manhattan": h_manhattan,
    "LinearConflict": h_linear_conflict
}

print(f"{'Puzzle':<12}{'Heuristic':<15}{'Solved':<8}{'Moves':<8}{'Time(s)':<10}{'Nodes':<10}")
for name, puzzle in puzzles.items():
    for hname, hfun in heuristics.items():
        path, nodes, t = astar(puzzle, hfun)
        solved = bool(path)
        moves = len(path)-1 if solved else "-"
        print(f"{name:<12}{hname:<15}{str(solved):<8}{str(moves):<8}{t:.4f}   {nodes:<10}")
